---
title: mysql优化初识
tags: mysql,优化
grammar_zjwJava: true
---


- 连接查询
  - INNER JOIN(内连接)：只查询出公有的部分
  - LEFT JOIN(左连接)：查询出左边表中所有部分，右边表只查出公有的部分，其余为空
  - RIGHT JOIN(右连接)：查询出右边表中所有部分，左边表只查出公有的部分，其余为空
  - UNION(全连接)：左连接 UNION 右连接，会将公有的部分，不共有的部分都查出来，不共有的部分被连接表字段为空。(UNION会去重)

- 索引 
  - 基本结构：B+TREE
  - 创建：CREATE INDEX 索引名称 ON 表名(字段名)，其中字段名可以为多个字段，创建复合索引
  - 适合建立索引：
    - 主键自动建立唯一索引
    - 频繁作为查询条件的字段
    - 查询中需要排序字段(索引可以提高检索速度和排序速度) 
    - 分组的字段(分组前必排序)
  - 不适合建立索引
    - where条件中的字段
    - 经常更新的字段(更新不仅更新数据还要更新索引)
    - 数据比较少
    - 经常增删改的字段
   - 索引失效
     - where语句中复合索引左边字段不用，用右边的字段会使索引失效
     - where语句中复合索引对索引字段使用计算函数会使索引失效
     - where语句中复合索引对索引字段使用范围条件时，左边的索引会使右边的索引失效
     - where语句中复合索引索引字段字符串判断使用 != 、<>、is null 会使索引失效
     - or关键字会使索引失效
     - like通配符在左边会使索引失效

     -----使用覆盖索引可以解决以上索引失效情况，覆盖索引要求查询的字段都在复合索引字段中
- 分页
  - 问题：传统分页当offset过大时，查询时间明显增强
    原因：数据库在limit查询时，会从第一行一次往下查询，直到offset开始的位置，再将之前查询的数据去掉，开始取数据，导致在offset过大时，需要等待将之前的数据查询完
	解决：
	1. 在用索引查询时会减少等待时间，所以先用索引查询后作为子查询，再用INNER JOIN关联查询
	2. 使用条件判断，先用索引查询后，判断id>索引查询offset后，再进行查询
	3. 获得起始查询id，在通过条件判断后进行查询
- 函数
  - MAX: 当数据量较大时，使用max函数查找最大值会耗时较大，将字段创建索引优化，内部会使用优化器查询，时耗会大大减少
  - COUNT: 当使用COUNT(*)时，查询结果包含null的列，但是COUNT(字段)时，不会将这个字段为null的列包含进来，必须使用COUNT(字段 OR 字段 IS NULL)做统计
- 表锁
  - 读锁(共享锁)：LOCK TABLE 表名 READ， 解锁：UNLOCK TABLES
    - 同一个连接
      - 可以读取当前表的内容
      - 不能修改当前表的内容
      - 不能读取其他表的内容
    - 另一个连接
      - 可以读取表的内容
      - 不可以修改该表的内容，处于等待状态，当表被释放修改执行
      - 可以读取其他表的内容
  - 写锁(共享锁)：LOCK TABLE 表名 WRITE，解锁：UNLOCK TABLES
    - 同一个连接
      - 可以读取当前表的内容
      - 可以修改当前表的内容
      - 不能读取其他表的内容
    - 另一个连接
      - 不可以读取该表的内容，处于等待状态，当表被释放修改执行
      - 不可以修改该表的内容，处于等待状态，当表被释放修改执行
      - 可以读取其他表的内容
- 事物(ACID)
  - 原子性(atomicity)：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做
  - 一致性(consistency)：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的
  - 隔离性(isolation)：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰
  - 持久性(durability)：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响
- 悲观锁
  
  - 总是假设最坏的情况，每次去拿数据都认为别人会修改，所以每次拿数据都会加上锁，别人再想拿这个数据就会阻塞，直到commit后，别人才可以执行
- 乐观锁
  - 总是假设最好的情况，认为数据比人都不会修改，所以不会上锁，多适用于读的应用
    - 要使用乐观锁，需要用版本号方法实现，数据表中增加版本号信息字段，更新前先查询版本号，再在做更新操作时对比版本号时否相同，相同就满足条件，然后需要将版本号累加