>- ## Java底层：GC
>
  - #### GC如何判断一个对象需要回收
    - 引用计数算法：`对象增加一个计数器，当有引用它时，计数器就加一，当引用失效时，计数器就减一，任何时刻计数器为0的对象就是不可能再被使用的`  
        JVM并没有采用这种方式来判断对象是否已死  
        <font size=2>原因：循环引用会导致引用计数法失效，循环引用就是A类中一个属性引用了B类对象，B类中一个属性引用了A类对象，这样一来，就算你把A类和B类的实例对象引用置为null，它们还是不会被回收</font>
    - 可达性分析法：`通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称之为"引用链"，当一个对象到GC Roots没有任何的引用链相连时(从GC Roots到这个对象不可达)时，证明此对象是不可用的`  
      Java是用这种方法来判断是否需要回收对象
      - 作为GC Roots的对象有以下几种
        1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
        2. 方法区中类静态属性引用的对象
        3. 方法区中常量引用的对象
        4. 本地方法栈中JNI(Native方法)引用的对象
    - 被GC判断为”垃圾”的对象一定会回收吗  
      <font size=2>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)  
      如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它，finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行</font>
  - #### 垃圾回收算法
    - 标记清除：`标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象`
      - 适用场合
        - 存活对象较多的情况下比较高效
        - 适用于年老代（即旧生代）
      - 缺点
        - 容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块儿大小但是小于其中两块儿的和），会提前触发垃圾回收
        - 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）
    - 标记复制：`从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块儿新的内存上去，之后将原来的那一块儿内存全部回收掉(商业虚拟机都采用这种收集算法来回收新生代)`
        - 适用场合
          - 存活对象较少的情况下比较高效
          - 扫描了整个空间一次（标记存活对象并复制移动）
          - 适用于年轻代（即新生代）：基本上98%的对象是"朝生夕死"的，存活下来的会很少
        - 缺点
          - 需要一块儿空的内存空间
          - 需要复制移动对象
    - 标记整理(一种老年代的回收算法)：`首先从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高`
    - 分代收集算法(目前虚拟机使用的回收算法)：`在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用标记复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法`
      - 年轻代：复制算法
      - 年老代：标记-清除或标记-整理
  - #### 垃圾回收机制  
    <font size=2>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor  
  默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )  
    年轻代分为Eden区和survivor区（两块儿：from和to），且Eden:from:to==8:1:1</font>
    ![](http://wxf.zcoder.top/server/files/jvmxl.jpg)
    - JVM内存结构
      1. 新产生的对象优先分配在Eden区（除非配置了-XX:PretenureSizeThreshold，大于该值的对象会直接进入年老代）
      2. 当Eden区满了或放不下了，这时候其中存活的对象会复制到from区  
        <font size=2>这里，需要注意的是，如果存活下来的对象from区都放不下，则这些存活下来的对象全部进入年老代。之后Eden区的内存全部回收掉。</font>
      3. 之后产生的对象继续分配在Eden区，当Eden区又满了或放不下了，这时候将会把Eden区和from区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉Eden区和from区的所有内存
      4. 如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：-XX:MaxTenuringThreshold来配置），就会进入年老代了
      5. 当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）
    - 垃圾回收类型
      - Minor GC: `对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成`
        - 触发Minor GC的条件
          - 当Eden区满时，触发Minor GC
      - Full GC: `也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等`
        - 触发Full GC的条件
          - System.gc()方法的调用
          - 老年代（Tenured Gen）空间不足
          - Metaspace区内存达到阈值
          - 统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间
  - #### 引用类型
    - 强引用
      - Java中默认声明弱引用的就是强引用  
        ```java
        Object obj = new Object(); //只要obj还指向Object对象，         Object对象就不会被回收
        obj = null;  //手动置null
        ```
        只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。
    - 软引用
      - 软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。
      - 在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用
    - 弱引用
      - 弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收
      - 在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用
    - 虚引用
      - 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收
      - 在 JDK1.2 之后，用 PhantomReference 类来表示
      - 虚引用必须要和 ReferenceQueue 引用队列一起使用
    - 引用队列（ReferenceQueue）
      - 引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去
      - 程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施
      - 与软引用、弱引用不同，虚引用必须和引用队列一起使用
